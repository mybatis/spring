<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from target/site-src/es/markdown/batch.md at 20 mayo 2023
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>mybatis-spring &#x2013; </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>mybatis-spring</h1>
</div>
</div>
          <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="../../images/mybatis-logo.png"  alt="MyBatis logo" style="" /></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 20 mayo 2023<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.0.2</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html" title="Introducción"><span class="none"></span>Introducción</a></li>
    <li><a href="getting-started.html" title="Primeros pasos"><span class="none"></span>Primeros pasos</a></li>
    <li><a href="factorybean.html" title="SqlSessionFactoryBean"><span class="none"></span>SqlSessionFactoryBean</a></li>
    <li><a href="transactions.html" title="Transacciones"><span class="icon-chevron-right"></span>Transacciones</a></li>
    <li><a href="sqlsession.html" title="Uso de SqlSession"><span class="icon-chevron-right"></span>Uso de SqlSession</a></li>
    <li><a href="mappers.html" title="Inyección de Mappers"><span class="icon-chevron-right"></span>Inyección de Mappers</a></li>
    <li><a href="boot.html" title="Spring Boot"><span class="none"></span>Spring Boot</a></li>
    <li><a href="using-api.html" title="Uso del API de MyBatis"><span class="none"></span>Uso del API de MyBatis</a></li>
    <li class="active"><a><span class="none"></span>Spring Batch</a></li>
    <li><a href="sample.html" title="Código de ejemplo"><span class="none"></span>Código de ejemplo</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html" title="Información del proyecto"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html" title="Informes del proyecto"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Generado por Maven" class="poweredBy"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<p><a name="Spring_Batch"></a></p>
<h1>Spring Batch</h1>
<p>Desde la versi&#xf3;n 1.1.0 MyBatis-Spring proporciona dos beans para construir aplicaciones Spring Batch: <code>MyBatisPagingItemReader</code> y <code>MyBatisCursorItemReader</code> y <code>MyBatisBatchItemWriter</code>.
Also, As of version 2.0.0 provides three builder classes for supporting the Java Configuration: the <code>MyBatisPagingItemReaderBuilder</code>, the <code>MyBatisCursorItemReaderBuilder</code> and the <code>MyBatisBatchItemWriterBuilder</code>.</p>
<p><span class="label important">NOTA</span>
Esta secci&#xf3;n se refiere a <a class="externalLink" href="http://static.springsource.org/spring-batch/">Spring Batch</a> y no a sesiones batch de MyBatis. Para obtener informaci&#xf3;n sobre las sesiones batch ve a la secci&#xf3;n <a href="sqlsession.html">Usnado un SqlSession</a>.</p><section>
<h2><a name="MyBatisPagingItemReader"></a>MyBatisPagingItemReader</h2>
<p>Este bean es un <code>ItemReader</code> que lee registros de una base de datos usando paginaci&#xf3;n.</p>
<p>Ejecuta la sentencia especificada mediante la propiedad <code>setQueryId</code> para obtener los datos. La sentencia se ejecuta usando peticiones paginadas del tama&#xf1;o indicando en la propiedad <code>setPageSize</code>.
Al llamar al m&#xe9;todo <code>read()</code> &#xe9;ste devuelve el objeto que corresponde a la posici&#xf3;n actual y solicita m&#xe1;s p&#xe1;ginas si es necesario.</p>
<p>El reader recibe algunos parametros est&#xe1;ndar y la SQL deber&#xe1; hacer uso de algunos de ellos para construir un resultset del tama&#xf1;o requerido. Los parametros son:</p>
<ul>

<li><code>_page</code>: el n&#xfa;mero de p&#xe1;gina a leer (comenzando en 0)</li>
<li><code>_pagesize</code>: el tama&#xf1;o de la p&#xe1;gina, es decir, el n&#xfa;mero de filas a devolver</li>
<li><code>_skiprows</code>: el producto de <code>_page</code> por <code>_pagesize</code></li>
</ul>
<p>Se pueden mapear en un statement de tipo select de la siguiente forma:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;select id=&quot;getEmployee&quot; resultMap=&quot;employeeBatchResult&quot;&gt;
  SELECT id, name, job FROM employees ORDER BY id ASC LIMIT #{_skiprows}, #{_pagesize}
&lt;/select&gt;
</code></pre></div>
<p>A continuaci&#xf3;n se muestra un ejemplo de configuraci&#xf3;n:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;reader&quot; class=&quot;org.mybatis.spring.batch.MyBatisPagingItemReader&quot;&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
  &lt;property name=&quot;queryId&quot; value=&quot;com.my.name.space.batch.EmployeeMapper.getEmployee&quot; /&gt;
&lt;/bean&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @Bean
  public MyBatisPagingItemReader&lt;Employee&gt; reader() {
    return new MyBatisPagingItemReaderBuilder&lt;Employee&gt;()
        .sqlSessionFactory(sqlSessionFactory())
        .queryId(&quot;com.my.name.space.batch.EmployeeMapper.getEmployee&quot;)
        .build();
  }
}
</code></pre></div>
<p><b>Veamos un ejemplo m&#xe1;s complejo:</b></p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;dateBasedCriteriaReader&quot;
  class=&quot;org.mybatis.spring.batch.MyBatisPagingItemReader&quot;
  p:sqlSessionFactory-ref=&quot;batchReadingSessionFactory&quot;
  p:parameterValues-ref=&quot;datesParameters&quot;
  p:queryId=&quot;com.my.name.space.batch.ExampleMapper.queryUserInteractionsOnSpecificTimeSlot&quot;
  p:pageSize=&quot;200&quot;
  scope=&quot;step&quot;/&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;util:map id=&quot;datesParameters&quot; scope=&quot;step&quot;&gt;
  &lt;entry key=&quot;yesterday&quot; value=&quot;#{jobExecutionContext['EXTRACTION_START_DATE']}&quot;/&gt;
  &lt;entry key=&quot;today&quot; value=&quot;#{jobExecutionContext['TODAY_DATE']}&quot;/&gt;
  &lt;entry key=&quot;first_day_of_the_month&quot; value=&quot;#{jobExecutionContext['FIRST_DAY_OF_THE_MONTH_DATE']}&quot;/&gt;
  &lt;entry key=&quot;first_day_of_the_previous_month&quot; value=&quot;#{jobExecutionContext['FIRST_DAY_OF_THE_PREVIOUS_MONTH_DATE']}&quot;/&gt;
&lt;/util:map&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @StepScope
  @Bean
  public MyBatisPagingItemReader&lt;User&gt; dateBasedCriteriaReader(
      @Value(&quot;#{@datesParameters}&quot;) Map&lt;String, Object&gt; datesParameters) throws Exception {
    return new MyBatisPagingItemReaderBuilder&lt;User&gt;()
        .sqlSessionFactory(batchReadingSessionFactory())
        .queryId(&quot;com.my.name.space.batch.ExampleMapper.queryUserInteractionsOnSpecificTimeSlot&quot;)
        .parameterValues(datesParameters)
        .pageSize(200)
        .build();
  }

  @StepScope
  @Bean
  public Map&lt;String, Object&gt; datesParameters(
      @Value(&quot;#{jobExecutionContext['EXTRACTION_START_DATE']}&quot;) LocalDate yesterday,
      @Value(&quot;#{jobExecutionContext['TODAY_DATE']}&quot;) LocalDate today,
      @Value(&quot;#{jobExecutionContext['FIRST_DAY_OF_THE_MONTH_DATE']}&quot;) LocalDate firstDayOfTheMonth,
      @Value(&quot;#{jobExecutionContext['FIRST_DAY_OF_THE_PREVIOUS_MONTH_DATE']}&quot;) LocalDate firstDayOfThePreviousMonth) {
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;yesterday&quot;, yesterday);
    map.put(&quot;today&quot;, today);
    map.put(&quot;first_day_of_the_month&quot;, firstDayOfTheMonth);
    map.put(&quot;first_day_of_the_previous_month&quot;, firstDayOfThePreviousMonth);
    return map;
  }
}
</code></pre></div>
<p>El ejemplo anterior hace uso de tres cosas distintas:</p>
<ul>

<li><code>sqlSessionFactory</code>: Puedes tu propio sessionFactory, podr&#xed;a ser &#xfa;til si quires leer de varias bases de datos.</li>
<li><code>queryId</code>: Si el c&#xf3;digo accede a varias tablas, y tienes distintas sentencias de consulta, puede ser interesante usar ficheros de mapeo distintos con namespaces distintos.
En este caso, al referirte a la query, no olvides incluir el namespace correspondiente.</li>
<li><code>parameterValues</code>: Puedes pasar parametros adicionales en este mapa, el ejemplo de arriba usa un mapa que se construye usando una expresion SpEL y obteniendo valores del <code>jobExecutionContext</code>.
Las claves del mapa puede usarse en el fichero mapper de MyBatis (por ejemplo: <i>yesterday</i> se puede usar como <code>#{yesterday,jdbcType=TIMESTAMP}</code>).
Observa que el mapa y el reader se consutruyen en un solo <code>step</code> para que sea posible usar la expresi&#xf3;n SpEL con el <code>jobExecutionContext</code>.
Adicionalmente si los type handlers de MyBatis est&#xe1;n configurados correctamente puedes pasar instancias personalizadas como los parametros del ejemplo que son fechas JodaTime.</li>
<li><code>pageSize</code>: Si le flujo batch est&#xe1; configurado con un tama&#xf1;o de bloque (chunk size), es importante pasar esta informaci&#xf3;n al reader, y eso se hace mediante esta propiedad.</li>
</ul></section><section>
<h2><a name="MyBatisCursorItemReader"></a>MyBatisCursorItemReader</h2>
<p>Este bean es un <code>ItemReader</code> que lee registros de la base de datos usando un cursor.</p>
<p><span class="label important">NOTA</span>
Para usar este bean necesitas al menos MyBatis 3.4.0 o superior.</p>
<p>Ejecuta la sentencia especificada mediante la propiedad <code>setQueryId</code> para obtener los datos usando el m&#xe9;todo <code>selectCursor()</code>.
Al llamar al m&#xe9;todo <code>read()</code> se devolver&#xe1; el siguiente elemento del cursor hasta que no quede ninguno por devolver.</p>
<p>El reader usa una conexi&#xf3;n separada para que la sentencia no participe en ninguna transacci&#xf3;n creada como parte del proceso del step.</p>
<p>Cuando se usar un cursor puedes usar una sentencia convencional:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;select id=&quot;getEmployee&quot; resultMap=&quot;employeeBatchResult&quot;&gt;
  SELECT id, name, job FROM employees ORDER BY id ASC
&lt;/select&gt;
</code></pre></div>
<p>A continuaci&#xf3;n se muestra un ejemplo de configuraci&#xf3;n:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;reader&quot; class=&quot;org.mybatis.spring.batch.MyBatisCursorItemReader&quot;&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
  &lt;property name=&quot;queryId&quot; value=&quot;com.my.name.space.batch.EmployeeMapper.getEmployee&quot; /&gt;
&lt;/bean&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @Bean
  public MyBatisCursorItemReader&lt;Employee&gt; reader() {
    return new MyBatisCursorItemReaderBuilder&lt;Employee&gt;()
        .sqlSessionFactory(sqlSessionFactory())
        .queryId(&quot;com.my.name.space.batch.EmployeeMapper.getEmployee&quot;)
        .build();
  }
}
</code></pre></div></section><section>
<h2><a name="MyBatisBatchItemWriter"></a>MyBatisBatchItemWriter</h2>
<p>Es un <code>ItemWriter</code> que usa las capacidades de batch de <code>SqlSessionTemplate</code> para ejecutar sentencias batch para todos los elementos (items) proporcionados.
El <code>SqlSessionFactory</code> debe configurarse con un executor de tipo <code>BATCH</code>.</p>
<p>Ejecuta la sentencia indicada en la propiedad <code>statementId</code> cuando se invoca a <code>write()</code>. Se supone que <code>write()</code> se invoca dentro de una transacci&#xf3;n.</p>
<p>A continuaci&#xf3;n se muestra un ejemplo de configuraci&#xf3;n:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;writer&quot; class=&quot;org.mybatis.spring.batch.MyBatisBatchItemWriter&quot;&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
  &lt;property name=&quot;statementId&quot; value=&quot;com.my.name.space.batch.EmployeeMapper.updateEmployee&quot; /&gt;
&lt;/bean&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @Bean
  public MyBatisBatchItemWriter&lt;User&gt; writer() {
    return new MyBatisBatchItemWriterBuilder&lt;User&gt;()
        .sqlSessionFactory(sqlSessionFactory())
        .statementId(&quot;com.my.name.space.batch.EmployeeMapper.updateEmployee&quot;)
        .build();
  }
}
</code></pre></div>
<p><b>Converting a item that read using ItemReader to an any parameter object:</b></p>
<p>By default behavior, the <code>MyBatisBatchItemWriter</code> passes a item that read using <code>ItemReader</code> (or convert by <code>ItemProcessor</code>) to the MyBatis(<code>SqlSession#update()</code>) as the parameter object.
If you want to customize a parameter object that passes to the MyBatis, you can realize to use the <code>itemToParameterConverter</code> option. For example using <code>itemToParameterConverter</code> option, you can passes any objects other than the item object to the MyBatis.
Follows below a sample:</p>
<p>At first, you create a custom converter class (or factory method). The following sample uses a factory method.</p>

<div class="source"><pre class="prettyprint"><code class="language-java">public class ItemToParameterMapConverters {
  public static &lt;T&gt; Converter&lt;T, Map&lt;String, Object&gt;&gt; createItemToParameterMapConverter(String operationBy, LocalDateTime operationAt) {
    return item -&gt; {
      Map&lt;String, Object&gt; parameter = new HashMap&lt;&gt;();
      parameter.put(&quot;item&quot;, item);
      parameter.put(&quot;operationBy&quot;, operationBy);
      parameter.put(&quot;operationAt&quot;, operationAt);
      return parameter;
    };
  }
}
</code></pre></div>
<p>At next, you write a sql mapping.</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;select id=&quot;createPerson&quot; resultType=&quot;org.mybatis.spring.sample.domain.Person&quot;&gt;
    insert into persons (first_name, last_name, operation_by, operation_at)
           values(#{item.firstName}, #{item.lastName}, #{operationBy}, #{operationAt})
&lt;/select&gt;
</code></pre></div>
<p>At last, you configure the <code>MyBatisBatchItemWriter</code>.</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @Bean
  public MyBatisBatchItemWriter&lt;Person&gt; writer() throws Exception {
    return new MyBatisBatchItemWriterBuilder&lt;Person&gt;()
        .sqlSessionFactory(sqlSessionFactory())
        .statementId(&quot;org.mybatis.spring.sample.mapper.PersonMapper.createPerson&quot;)
        .itemToParameterConverter(createItemToParameterMapConverter(&quot;batch_java_config_user&quot;, LocalDateTime.now()))
        .build();
  }
}
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;writer&quot; class=&quot;org.mybatis.spring.batch.MyBatisBatchItemWriter&quot;&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
  &lt;property name=&quot;statementId&quot; value=&quot;org.mybatis.spring.sample.mapper.PersonMapper.createPerson&quot;/&gt;
  &lt;property name=&quot;itemToParameterConverter&quot;&gt;
    &lt;bean class=&quot;org.mybatis.spring.sample.config.SampleJobConfig&quot; factory-method=&quot;createItemToParameterMapConverter&quot;&gt;
      &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;batch_xml_config_user&quot;/&gt;
      &lt;constructor-arg type=&quot;java.time.LocalDateTime&quot; value=&quot;#{T(java.time.LocalDateTime).now()}&quot;/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre></div>
<p><b>Escribiendo en distintas tablas usando composite writers (con algunos condicionantes):</b></p>
<p>Esta t&#xe9;cnica s&#xf3;lo puede usarse con MyBatis 3.2+, por que hab&#xed;a un <a class="externalLink" href="http://code.google.com/p/mybatis/issues/detail?id=741">error</a> en las versiones anteriores que hac&#xed;an que el writer funcionara de forma incorrecta.</p>
<p>Si el batch necesita escribir datos complejos, como registros con asociaciones, o en distintas bases de datos, entonces es necesario sortear el problema de que los insert statements solo pueden escribir en una tabla.
Para conseguir esto debes preparar un <i>Item</i> para que sea escrito por el writer. Sin embargo, dependiendo de las circunstancias puede ser interesante usar la siguiente t&#xe9;cnica.
El truco siguiente funciona con items con asociaciones simples o con tablas no relacionadas.</p>
<p>Elabora el <code>item</code> de forma que <i>contenta</i> todos los resgistros distintos. Supon que para cada <code>item</code> hay una <i>Interaction</i> que tiene una asociaci&#xf3;n <i>InteractionMetadata</i> y dos filas no asociadas <i>VisitorInteraction</i> and <i>CustomerInteraction</i>.
El objeto contenedor ser&#xe1; de la siguiente forma:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">public class InteractionRecordToWriteInMultipleTables {
  private final VisitorInteraction visitorInteraction;
  private final CustomerInteraction customerInteraction;
  private final Interaction interaction;
  // ...
}
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">public class Interaction {
  private final InteractionMetadata interactionMetadata;
}
</code></pre></div>
<p>Entonces en la configuraci&#xf3;n de spring habr&#xe1; un <code>CompositeItemWriter</code> que usar&#xe1; writers delegados configurados especificamente para cada tipo de registro.
Fijate que el <i>InteractionMetadata</i> es una asociaci&#xf3;in en el ejemplo por lo que debe ser escrita antes para que la Interaction pueda recibir la clave generada.</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;interactionsItemWriter&quot; class=&quot;org.springframework.batch.item.support.CompositeItemWriter&quot;&gt;
  &lt;property name=&quot;delegates&quot;&gt;
    &lt;list&gt;
      &lt;ref bean=&quot;visitorInteractionsWriter&quot;/&gt;
      &lt;ref bean=&quot;customerInteractionsWriter&quot;/&gt;

      &lt;!-- Order is important --&gt;
      &lt;ref bean=&quot;interactionMetadataWriter&quot;/&gt;
      &lt;ref bean=&quot;interactionWriter&quot;/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-java">@Configuration
public class BatchAppConfig {
  @Bean
  public CompositeItemWriter&lt;?&gt; interactionsItemWriter() {
    CompositeItemWriter compositeItemWriter = new CompositeItemWriter();
    List&lt;ItemWriter&lt;?&gt;&gt; writers = new ArrayList&lt;&gt;(4);
    writers.add(visitorInteractionsWriter());
    writers.add(customerInteractionsWriter());
    writers.add(interactionMetadataWriter());
    writers.add(interactionWriter());
    compositeItemWriter.setDelegates(writers);
    return compositeItemWriter;
  }
}
</code></pre></div>
<p>Cada writer delegados se configura como sea necesario, por ejemplo para <i>Interaction</i> y <i>InteractionMetadata</i>:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;interactionMetadataWriter&quot;
  class=&quot;org.mybatis.spring.batch.MyBatisBatchItemWriter&quot;
  p:sqlSessionTemplate-ref=&quot;batchSessionTemplate&quot;
  p:statementId=&quot;com.my.name.space.batch.InteractionRecordToWriteInMultipleTablesMapper.insertInteractionMetadata&quot;/&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;interactionWriter&quot;
  class=&quot;org.mybatis.spring.batch.MyBatisBatchItemWriter&quot;
  p:sqlSessionTemplate-ref=&quot;batchSessionTemplate&quot;
  p:statementId=&quot;com.my.name.space.batch.InteractionRecordToWriteInMultipleTablesMapper.insertInteraction&quot;/&gt;
</code></pre></div>
<p>Al igual que con el reader el <code>statementId</code> puede hacer referencia al statement con un namespace como prefijo.</p>
<p>Ahora es debe elaborarse el fichero de mapeo para cada tipo de registro, de la siguiente forma:</p>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;insert id=&quot;insertInteractionMetadata&quot;
  parameterType=&quot;com.my.batch.interactions.item.InteractionRecordToWriteInMultipleTables&quot;
  useGeneratedKeys=&quot;true&quot;
  keyProperty=&quot;interaction.interactionMetadata.id&quot;
  keyColumn=&quot;id&quot;&gt;
  &lt;!-- the insert statement using #{interaction.interactionMetadata.property,jdbcType=...} --&gt;
&lt;/insert&gt;
</code></pre></div>

<div class="source"><pre class="prettyprint"><code class="language-xml">&lt;insert id=&quot;insertInteraction&quot;
  parameterType=&quot;com.my.batch.interactions.item.InteractionRecordToWriteInMultipleTables&quot;
  useGeneratedKeys=&quot;true&quot;
  keyProperty=&quot;interaction.id&quot;
  keyColumn=&quot;id&quot;&gt;
  &lt;!--
   the insert statement using #{interaction.property,jdbcType=...} for regular properties
   and #{interaction.interactionMetadata.property,jdbcType=...} for the InteractionMetadata property
  --&gt;
&lt;/insert&gt;
</code></pre></div>
<p>Lo que sucede es que primeramente se llamar&#xe1; a <code>insertInteractionMetadata</code>, y la sentencia de update est&#xe1; configurada para devolver las claves autogeneradas (<code>keyProperty</code> y <code>keyColumn</code>).
Una vez que el <code>InteractionMetadata</code> se ha almacenado por esta sentencia se puede ejecutar la siguiente para escribir el objeto padre <code>Interaction</code> mediante <code>insertInteraction</code>.</p>
<p><i><b>Sin embargo, ten en cuenta que los drivers JDBC se comportan distinto en este aspecto. A la fecha en la que se escribe esto
el driver H2 1.3.168 solo devuelve el &#xfa;ltimo ID incluso en modo BATCH (see <code>org.h2.jdbc.JdbcStatement#getGeneratedKeys</code>),
mientras que el driver JDBC de MySQL se comporta como es de esperar y devuelve todos los IDs.</b></i></p></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2010&#x2013;2023
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
